from rest_framework import serializers
from .models import(
    ChatRoom, User, Club, Event, Post, 
    Comment, PostLike, PostReport, LostAndFoundItem, MarketplaceItem,  
    ConnectionRequest, Connection,
    Message, ChatRoom,
)
from django.contrib.auth import get_user_model
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
import base64
import uuid
import imghdr
from django.core.files.base import ContentFile
import logging

logger = logging.getLogger(__name__)

User = get_user_model()

class UserSerializer(serializers.ModelSerializer):
    """
    Serializer for the User model.
    This serializer handles the serialization and deserialization of User instances.
    """
    
    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'course', 'year', 'profile_picture', 'last_seen', 'is_online']
        read_only_fields = ['id']  # id is read-only, as it is auto-generated by Django
        extra_kwargs = {
            'username': {'required': True, 'max_length': 150},
            'email': {'required': False, 'max_length': 254},
            'course': {'required': False, 'max_length': 100},
            'year': {'required': False},
            'profile_picture': {'required': False}
        }
        
    def validate_email(self, value):
        """
        Validate that the email is unique.
        """
        if User.objects.filter(email=value).exists():
            raise serializers.ValidationError("This email is already in use.")
        return value
    
    def validate_username(self, value):
        """
        Validate that the username is unique.
        """
        if User.objects.filter(username=value).exists():
            raise serializers.ValidationError("This username is already taken.")
        return value
    
    def create(self, validated_data):
        """
        Create a new User instance.
        """
        return User.objects.create_user(**validated_data)
    
    def update(self, instance, validated_data):
        """
        Update an existing User instance.
        """
        instance.username = validated_data.get('username', instance.username)
        instance.email = validated_data.get('email', instance.email)
        instance.course = validated_data.get('course', instance.course)
        instance.year = validated_data.get('year', instance.year_of_study)
        profile_picture = validated_data.get('profile_picture')
        if profile_picture is not None:
            instance.profile_picture = profile_picture
        instance.save()
        return instance
    
    
class UserListSerializer(serializers.ModelSerializer):
    """
    Minimal serializer for user listing - only username and profile picture
    """
    class Meta:
        model = User
        fields = ['id', 'username', 'profile_picture']


    
    
    
class RegistrationSerializer(serializers.ModelSerializer):
    profile_picture_base64 = serializers.CharField(write_only=True, required=False)

    class Meta:
        model = User
        fields = ['username', 'email', 'password', 'course', 'year', 'profile_picture', 'profile_picture_base64']
        extra_kwargs = {
            'password': {'write_only': True, 'min_length': 8},
            'course': {'required': False, 'max_length': 100},
            'year': {'required': False, 'min_value': 1, 'max_value': 6},
            'profile_picture': {'required': False}
        }

    def validate(self, data):
        base64_image = data.pop('profile_picture_base64', None)

        if base64_image:
            try:
                format, imgstr = base64_image.split(';base64,') if 'base64,' in base64_image else ('', base64_image)
                ext = format.split('/')[-1] if format else 'jpg'
                img_data = base64.b64decode(imgstr)

                # Verify the image type
                img_type = imghdr.what(None, h=img_data)
                if img_type not in ['jpeg', 'png', 'jpg']:
                    raise serializers.ValidationError('Unsupported image type')

                file_name = f"{uuid.uuid4()}.{img_type}"
                data['profile_picture'] = ContentFile(img_data, name=file_name)

            except Exception as e:
                raise serializers.ValidationError({'profile_picture_base64': 'Invalid base64 image data'})

        return data

    def create(self, validated_data):
        user = User(
            username=validated_data['username'],
            email=validated_data['email'],
            course=validated_data.get('course'),
            year=validated_data.get('year'),
            profile_picture=validated_data.get('profile_picture')
        )
        user.set_password(validated_data['password'])
        user.save()
        return user    
    


class UserProfileSerializer(serializers.ModelSerializer):
    id = serializers.IntegerField(source='user.id', read_only=True)
    class Meta:
        model = User
        fields = ['id','username', 'email', 'course', 'year', 'profile_picture', 'last_seen', 'is_online']
        # read_only_fields = ['username']  # Optional: Disallow changing username
    

# class UserDetailSerializer(serializers.ModelSerializer):
#     username = serializers.CharField(source='user.username', read_only=True)
#     email = serializers.CharField(source='user.email', read_only=True)
#     profile_picture = serializers.ImageField(read_only=True)
#     course = serializers.CharField(read_only=True)
#     year = serializers.CharField(read_only=True)
    
#     class Meta:
#         model = User
#         fields = ['id', 'username', 'email', 'profile_picture', 'course', 'year']
    
    

class UserDetailSerializer(serializers.ModelSerializer):
    """
    Serializer for user profile details - updated for custom User model
    """
    profile_picture_url = serializers.SerializerMethodField()
    
    class Meta:
        model = User
        fields = [
            'id', 
            'username', 
            'email', 
            'first_name',
            'last_name',
            'course', 
            'year', 
            'profile_picture',
            'profile_picture_url',
            'is_online',
            'last_seen',
            'date_joined'
        ]
        read_only_fields = ['id', 'username', 'email', 'date_joined', 'last_seen']
    
    def get_profile_picture_url(self, obj):
        """
        Get full URL for profile picture
        """
        if obj.profile_picture:
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(obj.profile_picture.url)
            return obj.profile_picture.url
        return None



class ClubSerializer(serializers.ModelSerializer):
    members_count = serializers.IntegerField(source='members.count', read_only=True)
    joined = serializers.SerializerMethodField()

    class Meta:
        model = Club
        fields = ['id', 'name', 'description', 'category', 'members_count', 'joined']

    def get_joined(self, obj):
        user = self.context['request'].user
        return user in obj.members.all()

class EventSerializer(serializers.ModelSerializer):
    attendees_count = serializers.IntegerField(source='attendees.count', read_only=True)
    rsvped = serializers.SerializerMethodField()

    class Meta:
        model = Event
        fields = [
            'id', 'title', 'description', 'location',
            'start_time', 'end_time', 'club', 'category',
            'attendees_count', 'rsvped'
        ]

    def get_rsvped(self, obj):
        user = self.context['request'].user
        return user in obj.attendees.all()





class CommentSerializer(serializers.ModelSerializer):
    author_name = serializers.CharField(source='author.username', read_only=True)

    class Meta:
        model = Comment
        fields = ['id', 'author_name', 'content', 'created_at']
        read_only_fields = ['id', 'created_at', 'author_name']  # Optional: Disallow changing id and created_at


class PostSerializer(serializers.ModelSerializer):
    author_name = serializers.CharField(source='author.username', read_only=True)
    author_avatar = serializers.CharField(source='user.profile_picture', read_only=True)
    likes_count = serializers.IntegerField(source='likes.count', read_only=True)
    comments_count = serializers.IntegerField(source='comments.count', read_only=True)
    comments = CommentSerializer(many=True, read_only=True)
    # comments = CommentSerializer(many=True, read_only=True, source='comments_root')
    image = serializers.ImageField(required=False, allow_null=True)
    is_liked_by_user = serializers.SerializerMethodField()
    
    class Meta:
        model = Post
        fields = ['id', 'title', 'content', 'category', 'created_at',
            'author_name', 'author_avatar', 'likes_count', 
            'comments_count', 'comments', 'image', 'is_liked_by_user'
        ]
        
        
    def get_likes_count(self, obj):
        return obj.likes.count()

    def get_comments_count(self, obj):
        # Assuming you have a Comment model with a foreign key to Post
        return obj.comments.count() if hasattr(obj, 'comments') else 0

    def get_is_liked_by_user(self, obj):
        request = self.context.get('request')
        if request and hasattr(request, 'user') and request.user.is_authenticated:
            return obj.likes.filter(user=request.user).exists()
        return False





class PostLikeSerializer(serializers.ModelSerializer):
    class Meta:
        model = PostLike
        fields = ['post', 'user']

class PostReportSerializer(serializers.ModelSerializer):
    class Meta:
        model = PostReport
        fields = ['post', 'reporter', 'reason']




class Base64ImageField(serializers.ImageField):
    """
    A Django REST framework field for handling image-uploads through raw post data.
    It uses base64 for encoding and decoding the contents of the file.
    """

    def to_internal_value(self, data):
        # Check if this is a base64 string
        if isinstance(data, str) and data.startswith('data:image'):
            # Check that the base64 string is in the correct format
            try:
                # Extract the base64 part
                format, imgstr = data.split(';base64,')
                ext = format.split('/')[-1]

                # Generate a unique filename
                filename = f'{uuid.uuid4()}.{ext}'
                
                # Create a ContentFile from the base64 data
                data = ContentFile(base64.b64decode(imgstr), name=filename)
            except ValueError:
                raise serializers.ValidationError('Invalid image format')

        return super().to_internal_value(data)


# Updated serializer using the custom field
class LostAndFoundItemSerializer(serializers.ModelSerializer):
    owner = serializers.StringRelatedField(read_only=True)
    image = Base64ImageField(required=False, allow_null=True)

    class Meta:
        model = LostAndFoundItem
        fields = '__all__'




# class MarketplaceItemSerializer(serializers.ModelSerializer):
#     seller = UserSerializer(read_only=True)
#     image = Base64ImageField(required=False, allow_null=True)
#     is_current_user = serializers.SerializerMethodField()

#     class Meta:
#         model = MarketplaceItem
#         fields = '__all__'
#         read_only_fields = ['seller', 'created_at', 'is_sold']

#     def get_seller(self, obj):
#         return {
#             'id': obj.seller.id,
#             'username': obj.seller.username,
#             'email': getattr(obj.seller, 'email', None),
#             'is_current_user': self.context.get('request').user == obj.seller if self.context.get('request') else False
#         }

#     def get_is_current_user(self, obj):
#         request = self.context.get('request')
#         return request.user == obj.seller if request else False


class MarketplaceItemSerializer(serializers.ModelSerializer):
    seller = UserSerializer(read_only=True)
    image = Base64ImageField(required=False, allow_null=True, allow_empty_file=True)
    is_current_user = serializers.SerializerMethodField()

    class Meta:
        model = MarketplaceItem
        fields = '__all__'
        read_only_fields = ['seller', 'created_at', 'is_sold']

    def validate_category(self, value):
        """Validate category choice"""
        valid_categories = [choice[0] for choice in MarketplaceItem.CATEGORY_CHOICES]
        if value not in valid_categories:
            raise serializers.ValidationError(f"Invalid category. Choose from: {valid_categories}")
        return value

    def validate_condition(self, value):
        """Validate condition choice"""
        valid_conditions = [choice[0] for choice in MarketplaceItem.CONDITION_CHOICES]
        if value not in valid_conditions:
            raise serializers.ValidationError(f"Invalid condition. Choose from: {valid_conditions}")
        return value

    def validate_price(self, value):
        """Validate price"""
        if value <= 0:
            raise serializers.ValidationError("Price must be greater than 0")
        if value > 99999999.99:
            raise serializers.ValidationError("Price is too large")
        return value

    def validate_title(self, value):
        """Validate title"""
        if len(value.strip()) < 3:
            raise serializers.ValidationError("Title must be at least 3 characters")
        if len(value.strip()) > 100:
            raise serializers.ValidationError("Title must be less than 100 characters")
        return value.strip()

    def validate_description(self, value):
        """Validate description"""
        if len(value.strip()) < 10:
            raise serializers.ValidationError("Description must be at least 10 characters")
        return value.strip()

    def create(self, validated_data):
        """Override create to set seller from request user"""
        request = self.context.get('request')
        if request and request.user:
            validated_data['seller'] = request.user
        else:
            raise serializers.ValidationError("User authentication required")
        
        logger.info(f"Creating marketplace item with data: {validated_data}")
        return super().create(validated_data)

    def get_seller(self, obj):
        return {
            'id': obj.seller.id,
            'username': obj.seller.username,
            'email': getattr(obj.seller, 'email', None),
            'is_current_user': self.context.get('request').user == obj.seller if self.context.get('request') else False
        }

    def get_is_current_user(self, obj):
        request = self.context.get('request')
        return request.user == obj.seller if request and request.user else False








class ConnectionRequestSerializer(serializers.ModelSerializer):
    sender = UserSerializer(read_only=True)
    receiver = UserSerializer(read_only=True)
    sender_profile = UserProfileSerializer(source='sender.user', read_only=True)
    receiver_profile = UserProfileSerializer(source='receiver.user', read_only=True)
    
    class Meta:
        model = ConnectionRequest
        fields = ['id', 'sender', 'receiver', 'sender_profile', 'receiver_profile', 
                 'status', 'created_at', 'updated_at']

class ConnectionSerializer(serializers.ModelSerializer):
    user1 = UserSerializer(read_only=True)
    user2 = UserSerializer(read_only=True)
    user1_profile = UserProfileSerializer(source='user1.user', read_only=True)
    user2_profile = UserProfileSerializer(source='user2.user', read_only=True)
    
    class Meta:
        model = Connection
        fields = ['id', 'user1', 'user2', 'user1_profile', 'user2_profile', 'created_at']



class MessageSerializer(serializers.ModelSerializer):
    sender = UserSerializer(read_only=True)
    sender_profile = UserProfileSerializer(source='sender.user', read_only=True)
    
    class Meta:
        model = Message
        fields = [
            'id', 'chat_room', 'sender', 'sender_profile', 'message_type', 
            'content', 'file', 'is_read', 'created_at', 'updated_at', 
            'delivered_at', 'status', 'read_at', 'reply_to', 'reactions', 'thumbnail', 
            'duration', 'file_size'
        ]

class ChatRoomSerializer(serializers.ModelSerializer):
    user1 = UserSerializer(read_only=True)
    user2 = UserSerializer(read_only=True)
    user1_profile = UserProfileSerializer(source='user1.user', read_only=True)
    user2_profile = UserProfileSerializer(source='user2.user', read_only=True)
    last_message = serializers.SerializerMethodField()
    unread_count = serializers.SerializerMethodField()
    other_user = serializers.SerializerMethodField()
    other_user_profile = serializers.SerializerMethodField()
    
    class Meta:
        model = ChatRoom
        fields = ['id', 'user1', 'user2', 'user1_profile', 'user2_profile', 
                 'other_user', 'other_user_profile', 'last_message', 'unread_count',
                 'created_at', 'updated_at', 'is_group', 'group_name']
    
    def get_last_message(self, obj):
        last_message = obj.messages.first()
        if last_message:
            return MessageSerializer(last_message).data
        return None
    
    def get_unread_count(self, obj):
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            return obj.messages.filter(is_read=False).exclude(sender=request.user).count()
        return 0
    
    def get_other_user(self, obj):
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            other_user = obj.get_other_user(request.user)
            return UserSerializer(other_user).data
        return None
    
    def get_other_user_profile(self, obj):
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            other_user = obj.get_other_user(request.user)
            return UserProfileSerializer(other_user).data
            # return UserProfileSerializer(other_user.user).data
        return None
  